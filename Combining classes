#include<iostream>
#include<vector>
#include<cmath>
#include<algorithm>
#include<memory.h>
using namespace std;

int X[400010];
int Y[400010];
int Z[400010];
int L[400010];
int R[400010];
int K[400010];
int a[800010];
int f[800010];
long long g[800010];
int main() {
	int T;
	int iCase = 0;
	scanf("%d", &T);
	while (T--) {
		iCase++;
		int N, Q;
		scanf("%d%d", &N, &Q);
		int A1, B1, C1, M1;
		scanf("%d%d%d%d%d%d", &X[1], &X[2], &A1, &B1, &C1, &M1);
		for (int i = 3; i <= N; i++) {
			X[i] = ((long long)A1*X[i - 1] + (long long)B1 * X[i - 2] + C1) % M1;
		}
		int A2, B2, C2, M2;
		scanf("%d%d%d%d%d%d", &Y[1], &Y[2], &A2, &B2, &C2, &M2);
		for (int i = 3; i <= N; i++) {
			Y[i] = ((long long)A2*Y[i - 1] + (long long)B2 * Y[i - 2] + C2) % M2;
		}
		int A3, B3, C3, M3;
		scanf("%d%d%d%d%d%d", &Z[1], &Z[2], &A3, &B3, &C3, &M3);
		for (int i = 3; i <= Q; i++) {
			Z[i] = ((long long)A3*Z[i - 1] + (long long)B3 * Z[i - 2] + C3) % M3;
		}
		for (int i = 1; i <= N; i++) {
			L[i] = min(X[i], Y[i]) + 1;
			R[i] = max(X[i], Y[i]) + 2;
		}
		for (int i = 1; i <= Q; i++) {
			K[i] = Z[i] + 1;
		}

		//将L[i]和R[i]插入数组a
		int tot = 0;
		for (int i = 1; i <= N; i++) {
			a[tot++] = L[i];
			a[tot++] = R[i];
		}


		//将每个区间的两个端点值排序并去重之后，得到tot个互不相等的数值
		sort(a, a + tot);
		tot = unique(a, a + tot) - a;

		//得出每个区间端点的位置，每个端点转化为0到tot之间的值，每个端点唯一对应一个值（位置）
		for (int i = 1; i <= N; i++) {
			L[i] = lower_bound(a, a + tot, L[i]) - a;
			R[i] = lower_bound(a, a + tot, R[i]) - a;
		}

		//遇左加1，遇右减一
		memset(f, 0, sizeof(f));
		for (int i = 1; i <= N; i++) {
			f[L[i]]++;//左加1
			f[R[i]]--;//右减1
		}

		//统计每个端点被多少个区间包含
		for (int i = 1; i < tot; i++) {
			f[i] += f[i - 1];
		}


		//计算每个端点的后缀和，即分数>=x的个数
		for (int i = tot - 1; i >= 0; i--) {
			if (i == tot - 1) {//处理最大值的情况
				g[i] = f[i];
				continue;
			}
			g[i] = g[i + 1] + (long long)f[i] * (a[i + 1] - a[i]);//a是被排序去重过后的端点值
		}

		//二分查找，找到满足条件的某个值（0到tot之间）
		long long ans = 0;
		for (int i = 1; i <= Q; i++) {
			if (K[i] > g[0]) {
				continue;
			}
			int ret = 0;
			int l = 0, r = tot - 1;
			while (l <= r) {
				int mid = (l + r) / 2;
				if (g[mid] >= K[i]) {
					ret = mid;
					l = mid + 1;
				}
				else {
					r = mid - 1;
				}
			}

			int tmp = a[ret] + (g[ret] - K[i]) / f[ret];
			ans += (long long)tmp*i;
		}
		printf("Case #%d: %lld\n", iCase, ans);
	}
	return 0;
}
